##### 프로세스 강제종료(SIGKILL) 어떻게 해야하나요?#####

**1) `SIGTERM`을 무시하는 프로세스를 만듭니다.**
```bash
bash -c 'trap "" SIGTERM; echo "PID is $$"; echo "Ignoring SIGTERM, kill me with SIGKILL!"; while true; do sleep 1; done' &
```
```tech
bash,trap,echo,while,sleep
```
```desc
#### 🛡️ 종료 신호 무시 프로세스 만들기
`trap` 명령을 사용해 `SIGTERM` 종료 신호를 무시하는 특수 프로세스를 백그라운드에서 실행합니다.

- **`bash -c '...'`**: 따옴표 안의 스크립트를 새 셸에서 실행
- **`trap "" SIGTERM`**: `SIGTERM` 신호를 받았을 때 아무것도 하지 않도록 설정
- **`$`**: 현재 셸의 프로세스 ID(PID)

> 💡 이 프로세스는 일반적인 종료 요청(`kill PID`)에 반응하지 않아 강제 종료 테스트에 사용됩니다.
```

**2-1) 프로세스 PID를 변수( BAD_PID )에 저장합니다.**
```bash
BAD_PID=$!
```
```tech
bash
```
```desc
#### 🆔 문제 프로세스 PID 저장하기
바로 직전에 실행한 백그라운드 프로세스의 PID를 `BAD_PID` 변수에 저장합니다.

- **`BAD_PID=$!`**: `$!`는 가장 최근 백그라운드 프로세스의 PID를 담고 있는 셸 특수 변수입니다.

> 💡 PID를 변수에 저장하면 이후 명령어에서 편리하게 참조할 수 있습니다.
```

**2-2) 변수( BAD_PID )에 저장된 PID를 확인합니다.**
```bash
echo "Problem process PID: ${BAD_PID}"
```
```tech
echo
```
```desc
#### 💬 저장된 PID 확인하기
`echo`를 사용해 `BAD_PID` 변수에 저장된 값이 무엇인지 화면에 출력하여 확인합니다.

- **`echo`**: 문자열이나 변수의 값을 출력
- **`${BAD_PID}`**: `BAD_PID` 변수의 값을 참조

> 💡 변수에 값이 올바르게 저장되었는지 확인하는 것은 디버깅의 기본 단계입니다.
```

**3) `SIGTERM`으로 종료를 시도합니다.**
```bash
kill ${BAD_PID}
```
```tech
kill
```
```desc
#### 젠틀하게 종료 요청하기 (SIGTERM)
`kill` 명령어로 `SIGTERM` 신호를 보내 프로세스가 스스로 정상 종료하도록 요청합니다.

- **`kill ${BAD_PID}`**: 지정된 PID로 `SIGTERM` 신호를 전송 (기본 동작)

> 💡 하지만 이 프로세스는 `trap` 설정으로 `SIGTERM`을 무시하기 때문에 종료되지 않을 것입니다.
```

**4) 2초간 대기합니다.**
```bash
sleep 2
```
```tech
sleep
```
```desc
#### ⏳ 잠시 대기하기
`sleep` 명령을 사용해 2초 동안 잠시 기다립니다.

- **`sleep 2`**: 2초간 실행을 멈춤

> 💡 프로세스가 신호를 받고 반응(또는 무시)할 시간을 주기 위해 잠시 대기합니다.
```

**5) 프로세스가 여전히 살아있는지 확인합니다.**
```bash
if ps -p ${BAD_PID} > /dev/null; then
  echo "단계 진행: 프로세스가 아직 살아 있습니다."
  ps -p ${BAD_PID}  
else
  echo "단계 진행: 프로세스가 종료되었습니다."
fi
```
```tech
ps
```
```desc
#### 🔍 프로세스 생존 확인하기
`ps` 명령어로 `BAD_PID`를 가진 프로세스가 여전히 실행 중인지 확인합니다.

- **`ps -p ${BAD_PID}`**: 해당 PID의 프로세스 정보를 조회
- **`> /dev/null`**: `ps`의 표준 출력을 버려서 화면에 표시되지 않게 함
- **`if ... then ... else ... fi`**: `ps` 명령어의 성공 여부(프로세스 존재 여부)에 따라 다른 메시지를 출력

> 💡 `ps`가 성공하면(프로세스가 살아있으면) `if`문이 참이 됩니다.
```

**6) `SIGKILL` 시그널을 보내 강제 종료합니다.**
```bash
kill -9 ${BAD_PID}
```
```tech
kill
```
```desc
#### 💥 프로세스 강제 종료하기 (SIGKILL)
`SIGTERM`을 무시하는 프로세스를 `SIGKILL`(-9) 신호로 강제 종료합니다.

- **`kill -9`**: `SIGKILL` 신호를 보냄. 프로세스가 무시할 수 없는 가장 강력한 종료 신호입니다.
- **`${BAD_PID}`**: 강제 종료할 프로세스의 PID

> ⚠️ `SIGKILL`은 프로세스에게 정리할 시간을 주지 않고 즉시 종료시키므로, 최후의 수단으로 사용해야 합니다.
```

**7) 프로세스가 종료되었는지 확인합니다.**
```bash
if ps -p ${BAD_PID} > /dev/null; then
  echo "단계 진행: 프로세스가 아직 살아 있습니다."
  ps -p ${BAD_PID}  
else
  echo "단계 진행: 프로세스가 종료되었습니다."
fi
```
```tech
ps
```
```desc
#### ✅ 최종 종료 확인하기
`ps` 명령어를 다시 사용하여 `SIGKILL` 신호로 프로세스가 확실히 종료되었는지 확인합니다.

- **`if ps -p ${BAD_PID} ...`**: 프로세스의 존재 여부를 마지막으로 체크

> 💡 "프로세스가 종료되었습니다."라는 메시지가 출력되면 성공적으로 강제 종료된 것입니다.
```
