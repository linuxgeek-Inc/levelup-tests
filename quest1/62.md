##### 라이브러리 의존성 없이 독립적으로 실행 어떻게 하나요?#####

**1) 패키지 설치를 위해 CRB 저장소를 활성화합니다.**
```bash
sudo dnf config-manager --set-enabled crb
```
```tech
dnf
```
```desc
#### ⚙️ CRB 저장소 활성화하기
`dnf`를 사용하여 CRB(CodeReady Builder) 저장소를 활성화합니다. 이 저장소는 개발 및 컴파일에 필요한 추가 패키지들을 제공합니다.

- **`sudo`**: 관리자 권한으로 실행
- **`dnf config-manager`**: DNF 저장소 설정을 관리
- **`--set-enabled crb`**: 'crb' 저장소를 활성화

> 💡 CRB는 정적 라이브러리 같은 개발용 패키지를 설치할 때 필요할 수 있습니다.
```

**2) 간단한 C 소스 코드를 작성합니다.**
```bash
echo -e '#include <stdio.h>\n\nint main() {\n    printf("Hello, Statically Linked World!\\n");\n    return 0;\n}' > hello.c
```
```tech
echo
```
```desc
#### ✍️ 간단한 C 소스 코드 작성하기
`echo` 명령어를 사용하여 "Hello, Statically Linked World!"를 출력하는 간단한 C 언어 소스 파일을 생성합니다.

- **`echo -e`**: 백슬래시 이스케이프 문자(`\n` 등)를 해석하여 출력
- **`'...'`**: 여러 줄의 문자열을 하나로 묶음
- **`> hello.c`**: 출력 결과를 `hello.c` 파일로 저장 (덮어쓰기)

> 💡 C 코드를 컴파일하기 위해 먼저 `.c` 확장자를 가진 소스 파일을 만듭니다.
```

**3) 동적 링크 방식으로 컴파일합니다.**
* (동적 링크 방식: 필요한 라이브러리를 외부에서 참조하도록 만들어 용량을 줄이고 실행 시에 불러오게 하는 방식)
```bash
gcc -o hello_dynamic hello.c
```
```tech
gcc
```
```desc
#### 🔗 동적 링크로 컴파일하기
`gcc` 컴파일러를 이용해 C 소스 코드를 **동적 링크** 방식으로 컴파일하여 실행 파일을 만듭니다.

- **`gcc`**: C/C++ 컴파일러 명령어
- **`-o hello_dynamic`**: 출력될 실행 파일의 이름을 `hello_dynamic`으로 지정
- **`hello.c`**: 컴파일할 소스 파일

> 💡 동적 링크는 실행 파일의 크기가 작지만, 실행 시 시스템에 해당 라이브러리가 설치되어 있어야 합니다.
```

**4) 동적 링크 의존성을 확인합니다.**
```bash
ldd ./hello_dynamic
```
```tech
ldd
```
```desc
#### 🔎 동적 링크 의존성 확인하기
`ldd` 명령어로 `hello_dynamic` 실행 파일이 어떤 공유 라이브러리에 의존하고 있는지 확인합니다.

- **`ldd`**: 실행 파일의 공유 라이브러리 의존성을 출력
- **`./hello_dynamic`**: 검사할 실행 파일

> 💡 `libc.so.6`와 같은 공유 라이브러리 목록이 표시되며, 이 파일들이 있어야 실행이 가능함을 의미합니다.
```

**5) 정적 링크에 필요한 패키지를 설치합니다.**
```bash
sudo dnf install -y glibc-static libstdc++-static
```
```tech
dnf
```
```desc
#### 📦 정적 링크용 패키지 설치하기
정적 컴파일에 필요한 `glibc`와 `libstdc++`의 정적 라이브러리 버전을 설치합니다.

- **`sudo dnf install -y`**: 패키지를 자동으로 'yes'하며 설치
- **`glibc-static`**: C 표준 라이브러리의 정적 버전
- **`libstdc++-static`**: C++ 표준 라이브러리의 정적 버전

> 💡 정적 링크를 하려면 라이브러리의 `.a` 파일(아카이브)이 필요하며, 이 패키지들이 해당 파일을 제공합니다.
```

**6) 정적 링크 방식으로 컴파일합니다.**
```bash
gcc -static -o hello_static hello.c
```
```tech
gcc
```
```desc
#### 🔗 정적 링크로 컴파일하기
`-static` 옵션을 추가하여 필요한 모든 라이브러리 코드를 실행 파일에 포함시키는 **정적 링크** 방식으로 컴파일합니다.

- **`gcc`**: C/C++ 컴파일러
- **`-static`**: 정적 링크 옵션
- **`-o hello_static`**: 출력될 실행 파일의 이름을 `hello_static`으로 지정

> 💡 정적 링크된 파일은 크기가 커지지만, 다른 시스템에서도 라이브러리 의존성 없이 독립적으로 실행될 수 있습니다.
```

**7) 정적 링크 의존성을 확인합니다.**
```bash
ldd ./hello_static
```
```tech
ldd
```
```desc
#### ✅ 정적 링크 의존성 확인하기
`ldd`로 `hello_static` 파일을 확인하여 라이브러리 의존성이 사라졌는지 검증합니다.

- **`ldd ./hello_static`**: 정적 링크된 파일의 의존성 검사

> 💡 "not a dynamic executable" 라는 메시지가 출력되며, 외부 라이브러리에 의존하지 않음을 의미합니다.
```

**8) 두 파일의 크기를 비교합니다.**
```bash
ls -lh hello_dynamic hello_static
```
```tech
ls
```
```desc
#### ⚖️ 파일 크기 비교하기
`ls -lh` 명령어로 동적 링크된 파일과 정적 링크된 파일의 크기를 비교합니다.

- **`ls -lh`**: 파일의 상세 정보(크기, 권한 등)를 출력

> 💡 `hello_static` 파일이 라이브러리를 포함하고 있어 `hello_dynamic`보다 훨씬 큰 것을 확인할 수 있습니다.
```

**9) 라이브러리 의존성 없이 독립적으로 프로그램 실행**
```bash
./hello_static
```
```tech
bash
```
```desc
#### 🚀 독립적으로 프로그램 실행하기
정적 링크된 `hello_static` 파일을 직접 실행하여 "Hello, Statically Linked World!" 메시지가 출력되는지 확인합니다.

- **`./hello_static`**: 현재 디렉터리에 있는 `hello_static` 실행

> 💡 이 파일은 다른 시스템에 복사하더라도 `glibc` 같은 라이브러리가 없거나 버전이 달라도 문제없이 동일하게 실행됩니다. 이것이 정적 링크의 가장 큰 장점입니다.
```
