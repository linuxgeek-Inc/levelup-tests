##### 도커 네트워크와 iptables 충돌문제 #####

**1) 테스트용 알파인 컨테이너 실행**

```bash
docker run -it -d --name test_container alpine
```
```no-err-check
```

```tech
docker,run,alpine,bash
```

```desc
#### 🚀 테스트 컨테이너 실행
`docker run ...` 명령어로 가벼운 `alpine` 이미지를 사용하여 `test_container`라는 이름의 컨테이너를 백그라운드에서 실행합니다.

- **네트워크 연결**: 이 컨테이너는 기본 `bridge` 네트워크에 연결되어 외부와 통신할 준비를 합니다.

> 💡 네트워크 연결 테스트를 위한 작고 빠른 컨테이너를 준비하는 단계입니다.
```

**2) 도커가 생성한 iptables 규칙 확인**

```bash
sudo iptables -L | grep -A30 -i docker
```

```tech
sudo,iptables,grep,bash,rocky
```

```desc
#### 🔍 도커의 iptables 규칙 확인
`sudo iptables -L` 명령어로 현재 시스템의 방화벽 규칙을 확인하고, `grep`으로 `DOCKER`와 관련된 체인들을 필터링합니다.

- **DOCKER 체인**: 도커는 컨테이너의 네트워크 통신(특히 외부로 나가는 트래픽)을 관리하기 위해 `iptables`에 자신만의 규칙들을 자동으로 추가합니다. `FORWARD` 체인에서 `DOCKER-USER`와 `DOCKER` 체인으로 패킷을 보내는 것을 볼 수 있습니다.

> 💡 도커 컨테이너가 어떻게 외부와 통신할 수 있는지, 그 핵심에는 `iptables`의 NAT(Network Address Translation)와 포워딩 규칙이 있다는 것을 보여줍니다.
```

**3) 컨테이너 외부 네트워크 연결 확인**

```bash
docker exec test_container ping -c 2 8.8.8.8
```

```tech
docker,exec,ping,bash
```

```desc
#### ✅ 외부 네트워크 연결 테스트
`docker exec`를 사용하여 `test_container` 내부에서 `ping` 명령을 실행, Google DNS 서버(8.8.8.8)와 통신이 되는지 확인합니다.

- **정상 통신**: 도커가 설정한 `iptables` 규칙 덕분에 컨테이너는 외부 인터넷과 정상적으로 통신할 수 있습니다.

> 💡 현재 네트워크 설정이 정상임을 확인하는 단계입니다.
```

**4) 모든 iptables 규칙 초기화 (문제 상황 연출)**

```bash
sudo iptables -F
```

```tech
sudo,iptables,bash,rocky
```

```desc
#### 💣 iptables 규칙 강제 초기화
`sudo iptables -F` 명령어는 시스템의 모든 `iptables` 규칙을 삭제합니다. 이로 인해 도커가 컨테이너 통신을 위해 설정해 둔 규칙들도 모두 사라지게 됩니다.

- **-F, --flush**: 모든 체인의 규칙을 삭제합니다.

> 💡 방화벽 설정 변경이나 시스템 스크립트의 오작동으로 인해 도커의 네트워크가 마비되는 상황을 인위적으로 연출합니다.
```

**5) 초기화된 iptables 규칙 확인**

```bash
sudo iptables -L
```

```tech
sudo,iptables,bash,rocky
```

```desc
#### 텅 빈 규칙 확인
`sudo iptables -L` 명령어를 다시 실행해 보면, 이전에 보였던 `DOCKER` 관련 체인과 규칙들이 모두 사라지고 기본 정책만 남은 것을 확인할 수 있습니다.

- **연결고리 상실**: 컨테이너 트래픽을 처리해주던 규칙이 없어져 컨테이너는 외부와 통신할 수 없게 됩니다.

> 💡 문제가 발생했음을 눈으로 직접 확인하는 단계입니다.
```

**6) 도커 데몬 재시작 (문제 해결)**

```bash
sudo systemctl restart docker
```

```tech
sudo,systemctl,restart,docker,bash,rocky
```

```desc
#### 🔧 도커 데몬 재시작으로 규칙 복구
`sudo systemctl restart docker` 명령어로 도커 서비스를 재시작합니다. 도커 데몬은 시작될 때 자신에게 필요한 `iptables` 규칙이 없으면 자동으로 다시 생성하는 기능이 있습니다.

- **자동 복구**: 이 명령 한 번으로 사라졌던 모든 도커 관련 `iptables` 규칙이 원래대로 복구됩니다.

> 💡 "컨테이너 인터넷이 안될 때 도커 재시작"이 가장 기본적인 해결책 중 하나인 이유입니다.
```

**7) 복구된 iptables 규칙 확인**

```bash
sudo iptables -L
```

```tech
sudo,iptables,bash,rocky
```

```desc
#### 🎉 규칙 복구 확인
다시 `sudo iptables -L` 명령어를 실행하면, 도커 데몬이 재시작되면서 `DOCKER` 관련 체인과 규칙들을 모두 재 생성한 것을 확인할 수 있습니다.

- **원상 복구**: 처음 확인했던 것과 동일한 `iptables` 규칙들이 다시 설정되었습니다.

> 💡 문제 해결이 제대로 이루어졌는지 확인하는 과정입니다.
```

**8) 중지된 컨테이너 다시 시작**

```bash
docker start test_container
```

```tech
docker,start,bash
```

```desc
#### ▶️ 컨테이너 재시작
도커 데몬을 재시작하면 실행 중이던 컨테이너들이 중지될 수 있습니다. `docker start` 명령어로 `test_container`를 다시 시작합니다.

- **상태 확인 필요**: 실제 운영 환경에서는 `docker ps -a`로 컨테이너 상태를 확인하고 필요한 컨테이너들을 다시 시작해야 합니다.

> 💡 서비스 재시작 후에는 관련 서비스들이 정상적으로 다시 실행되었는지 확인하는 것이 중요합니다.
```

**9) 컨테이너 실행 상태 확인**

```bash
docker ps
```

```tech
docker,ps,bash
```

```desc
#### 📊 컨테이너 상태 확인
`docker ps` 명령어로 `test_container`가 현재 실행 중(Up) 상태인지 확인합니다.

- **Up 상태**: 컨테이너가 정상적으로 실행되고 있음을 의미합니다.

> 💡 다음 단계를 진행하기 전에 테스트 대상이 준비되었는지 확인합니다.
```

**10) 컨테이너 네트워크 연결 복구 최종 확인**

```bash
docker exec test_container ping -c 2 8.8.8.8
```

```tech
docker,exec,ping,bash
```

```desc
#### ✅ 최종 연결 테스트
`iptables` 규칙이 복구되고 컨테이너가 다시 실행된 상태에서, 마지막으로 `ping` 테스트를 다시 실행합니다.

- **통신 성공**: 이제 컨테이너는 다시 정상적으로 외부와 통신할 수 있습니다.

> 💡 `iptables` 규칙이 도커 컨테이너의 외부 통신에 얼마나 중요한지, 그리고 문제가 생겼을 때 어떻게 복구하는지를 보여주는 실습입니다.
```

**11) 실습 종료**

```bash
: quit
```

```tech
bash,rocky
```

```desc
#### 👋 실습 종료
실습을 종료를 의미하는 `quit` 명령어를 실행합니다.
현재 터미널 세션을 종료합니다.

> 💡 모든 실습을 마무리 후 사용합니다.
```
