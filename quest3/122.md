##### 도커 컨테이너 포트충돌 문제해결

**1) Nginx 컨테이너(web1) 8080 바인딩 실행**

```bash
docker run -d --name web1 -p 8080:80 nginx
```

```tech
docker,nginx,container,port,bash,rocky
```

```desc
#### 🚀 웹1 기동 (8080 → 80)
호스트 **8080** 포트를 컨테이너 **80** 포트에 연결해 Nginx를 백그라운드로 실행합니다.

- `-d`: 백그라운드 실행
- `-p 8080:80`: 포트 바인딩
```

**2) Nginx 컨테이너(web2) 8081 바인딩 실행**

```bash
docker run -d --name web2 -p 8081:80 nginx
```

```tech
docker,nginx,container,port,bash,rocky
```

```desc
#### 🚀 웹2 기동 (8081 → 80)
두 번째 Nginx 컨테이너를 **8081**로 노출합니다. 서로 다른 호스트 포트를 사용하므로 충돌이 없습니다.
```

**3) 실행 중 컨테이너 확인**

```bash
docker ps
```

```tech
docker,ps,bash,rocky
```

```desc
#### 🔍 상태 점검
현재 실행 중인 컨테이너 목록을 확인합니다.  
**PORTS**에 `0.0.0.0:8080->80/tcp`, `0.0.0.0:8081->80/tcp`가 보여야 합니다.
```

**4) 포트 충돌 유도(web3를 8080으로 시도)**

```bash
docker run -d --name web3 -p 8080:80 nginx
```

```tech
docker,nginx,port_conflict,bash,rocky
```

```desc
#### 💥 포트 충돌 재현
이미 web1이 **8080**을 점유하고 있어 바인딩 실패(예: *address already in use*)가 발생합니다.
```

**5) 모든 컨테이너(실패 포함) 상태 확인**

```bash
docker ps -a
```

```tech
docker,ps,bash,rocky
```

```desc
#### 🧾 실패 컨테이너 확인
실패한 web3가 **Exited** 상태로 보이는지 확인합니다. 로그를 보면 바인딩 에러 원인을 파악할 수 있습니다.
```

**6) 8080 점유 주체 확인(8080)**

```bash
ss -tplan | grep 8080
```

```tech
ss,ports,diagnostics,bash,rocky
```

```desc
#### 🔎 포트 8080 점유 확인
`ss -tplan`으로 8080을 누가 리슨 중인지 확인합니다. `users:(("docker-proxy"...))` 또는 `nginx`가 표시될 수 있습니다.
```

**7) 8081 점유 주체 확인(8081)**

```bash
ss -tplan | grep 8081
```

```tech
ss,ports,diagnostics,bash,rocky
```

```desc
#### 🔎 포트 8081 점유 확인
8081 포트를 web2가 점유 중인지 확인합니다. 문제 없이 리슨 중이면 정상입니다.
```

**8) 실패 컨테이너(web3) 정리**

```bash
docker rm web3
```

```tech
docker,cleanup,bash,rocky
```

```desc
#### 🧹 실패 컨테이너 삭제
충돌로 실패한 web3 컨테이너를 삭제해 재시도에 방해되지 않도록 정리합니다.
```

**9) web3를 다른 포트(8082)로 재기동**

```bash
docker run -d --name web3 -p 8082:80 nginx
```

```tech
docker,nginx,retry,bash,rocky
```

```desc
#### 🔁 대체 포트 사용
빈 포트 **8082**를 사용해 web3를 정상 기동합니다. 포트 충돌의 간단한 해결책입니다.
```

**10) 실행 상태 재확인**

```bash
docker ps
```

```tech
docker,ps,bash,rocky
```

```desc
#### ✅ 정상 동작 확인
web1(8080), web2(8081), web3(8082)가 **Up** 상태이며 각 포트가 올바르게 노출되는지 확인합니다.
```

**11) 8080 포트 회수를 위한 web1 중지**

```bash
docker stop web1
```

```tech
docker,stop,bash,rocky
```

```desc
#### ⛔ 점유 해제
8080을 점유하던 web1을 중지해 포트를 비웁니다. 운영 환경에선 중지 전 트래픽 전환을 고려하세요.
```

**12) 8080 재활용하여 web4 기동**

```bash
docker run -d --name web4 -p 8080:80 nginx
```

```tech
docker,nginx,redeploy,bash,rocky
```

```desc
#### 🔄 동일 포트 재사용
비워둔 **8080**을 web4가 사용하도록 기동합니다. 동일 포트를 안전하게 재활용하는 흐름입니다.
```

**13) 최종 상태 확인**

```bash
docker ps
```

```tech
docker,ps,bash,rocky
```

```desc
#### 📊 최종 점검
web2(8081), web3(8082), web4(8080)가 모두 **Up**인지 확인해 포트 충돌 해결을 마무리합니다.
```

**14) 실습 종료**

```bash
: quit
```

```tech
bash,rocky
```

```desc
#### 👋 실습 종료
실습을 종료를 의미하는 `quit` 명령어를 실행합니다.
현재 터미널 세션을 종료합니다.

> 💡 모든 실습을 마친 후 사용합니다.
```
