##### Nginx, httpd 포트 충돌은 어떻게 해결하나요? #####

**1) 프론트엔드 웹서버로 사용할 nginx를 설치합니다.**
```bash
sudo dnf install nginx -y
```
```tech
dnf
```
```desc
#### 📦 Nginx 웹서버 설치하기
프론트엔드 역할을 할 Nginx 웹서버를 설치합니다.

- **`sudo dnf install -y nginx`**: `dnf`를 이용해 `nginx` 패키지를 자동으로 설치합니다.

> 💡 Nginx는 가볍고 빠른 웹서버로, 주로 정적 파일 서빙이나 리버스 프록시 역할을 담당합니다.
```

**2) nginx 웹서버에서 실행할 index.html 파일을 생성합니다.**
```bash
echo "Hello, Nginx!" | sudo tee /usr/share/nginx/html/index.html
```
```tech
dnf
```
```desc
#### 📄 Nginx 기본 페이지 생성하기
Nginx가 서비스할 간단한 `index.html` 파일을 생성합니다.

- **`echo "..."`**: "Hello, Nginx!" 문자열을 출력합니다.
- **`| sudo tee ...`**: 파이프로 전달된 내용을 관리자 권한으로 파일에 씁니다.

> 💡 `tee`는 표준 출력과 파일에 동시에 내용을 쓸 수 있는 유용한 명령어입니다.
```

**3) nginx 웹서버를 실행합니다.**
```bash
sudo systemctl start nginx
```
```desc
#### ▶️ Nginx 서비스 시작하기
`systemctl`을 사용하여 Nginx 서비스를 시작합니다.

- **`sudo systemctl start nginx`**: `nginx` 서비스를 시작합니다.

> 💡 서비스를 시작해야 웹서버가 80번 포트를 사용하고 외부 요청에 응답할 수 있습니다.
```

**4) nginx 웹서버의 작동 상태를 확인합니다.**
```bash
sudo systemctl status nginx
```
```desc
#### 📊 Nginx 상태 확인하기
Nginx 서비스가 정상적으로 실행 중인지 확인합니다.

- **`sudo systemctl status nginx`**: `nginx` 서비스의 현재 상태를 보여줍니다.
- `Active: active (running)` 메시지가 보이면 정상입니다.

> 💡 서비스 실행에 문제가 있다면 이곳에서 원인을 파악할 단서를 얻을 수 있습니다.
```

**5) nginx 웹서버가 정상적으로 응답하는지 확인합니다.**
```bash
curl http://localhost
```
```desc
#### ✅ Nginx 응답 확인하기
`curl`을 이용해 로컬 웹서버에 접속하여 "Hello, Nginx!" 메시지가 잘 출력되는지 확인합니다.

- **`curl http://localhost`**: 로컬호스트(자기 자신)의 80번 포트로 HTTP 요청을 보냅니다.

> 💡 이 단계가 성공하면 Nginx가 80번 포트를 정상적으로 사용하고 있음을 의미합니다.
```

**6) 백엔드 웹서버로 사용할 httpd를 설치합니다.**
```bash
sudo dnf install httpd -y
```
```tech
dnf
```
```desc
#### 📦 httpd (Apache) 웹서버 설치하기
백엔드 역할을 할 `httpd` (Apache) 웹서버를 설치합니다.

- **`sudo dnf install -y httpd`**: `httpd` 패키지를 자동으로 설치합니다.

> 💡 `httpd`는 PHP 등 동적인 콘텐츠를 처리하는 데 강점이 있어 백엔드 서버로 많이 사용됩니다.
```

**7) index.php 파일이 들어갈 디렉토리를 생성합니다.**
```bash
sudo mkdir -p /var/www/html
```
```tech
dnf
```
```desc
#### 📁 httpd 문서 디렉터리 생성하기
`httpd`가 사용할 웹 문서 디렉터리(`/var/www/html`)를 생성합니다.

- **`sudo mkdir -p`**: 관리자 권한으로 디렉터리를 생성하며, 필요한 경우 상위 디렉터리까지 함께 만듭니다.

> 💡 웹서버마다 기본 문서 경로가 다르므로 확인이 필요합니다.
```

**8) httpd 웹서버에서 실행할 index.php 파일을 생성합니다.**
```bash
echo '<?php echo "Hello from httpd (PHP)!"; ?>' | sudo tee /var/www/html/index.php
```
```tech
dnf
```
```desc
#### 📄 httpd 기본 페이지(PHP) 생성하기
`httpd`가 서비스할 간단한 PHP 파일을 생성합니다.

- **`echo '...'`**: PHP 코드를 문자열로 출력합니다.
- **`| sudo tee ...`**: 관리자 권한으로 `/var/www/html/index.php` 파일에 내용을 씁니다.

> 💡 이 파일은 `httpd`가 정상적으로 PHP를 처리하는지 확인하는 데 사용됩니다.
```

**9) httpd 서비스를 실행합니다.**
```bash
sudo systemctl start httpd
```
```fail-pass
```
```desc
#### 💥 httpd 서비스 시작 (실패 예상)
`httpd` 서비스를 시작하려고 시도합니다.

- **`sudo systemctl start httpd`**: `httpd` 서비스 시작

> 💡 Nginx가 이미 80번 포트를 사용하고 있으므로, `httpd`는 동일한 포트를 사용하지 못해 시작에 실패할 것입니다. 이것이 바로 '포트 충돌'입니다.
```

**10) 로그를 통해 어느 부분에서 오류가 발생했는지 확인합니다. (q: 종료)**
```bash
sudo journalctl -xeu httpd.service
```
```desc
#### 🔍 오류 로그 확인하기
`journalctl`을 이용해 `httpd` 서비스의 상세 로그를 확인하여 실패 원인을 찾습니다.

- **`sudo journalctl -xeu httpd.service`**: `httpd` 서비스의 전체 로그와 추가 설명(-x)을 보여줍니다.
- "Address already in use" 또는 "포트 80에 바인딩할 수 없습니다"와 같은 메시지를 찾습니다.

> 💡 서비스 실행 실패 시 로그를 확인하는 것은 문제 해결의 가장 기본적인 단계입니다.
```

**11) netstat 명령어 사용을 위한 패키지를 설치합니다.**
```bash
sudo dnf install net-tools -y
```
```tech
dnf
```
```desc
#### 🛠️ net-tools 설치하기
포트 사용 현황을 확인할 `netstat` 명령어를 사용하기 위해 `net-tools` 패키지를 설치합니다.

- **`sudo dnf install -y net-tools`**: `net-tools` 패키지를 설치합니다.

> 💡 최신 시스템에서는 `ss` 명령어가 `netstat`을 대체하지만, `netstat`도 여전히 널리 사용됩니다.
```

**12) 80번 포트를 점유하고 있는 프로세스를 확인합니다.**
```bash
sudo netstat -tulpn | grep ':80'
```
```desc
#### 🕵️‍♂️ 80번 포트 사용 중인 프로세스 찾기
`netstat`으로 어떤 프로세스가 80번 포트를 사용(LISTEN)하고 있는지 확인합니다.

- **`sudo netstat -tulpn`**: TCP/UDP, 리스닝 소켓, 프로세스 정보, 숫자 주소로 표시
- **`| grep ':80'`**: 출력 결과에서 ':80'이 포함된 줄만 필터링

> 💡 이 결과를 통해 `nginx`가 80번 포트를 점유하고 있음을 확인할 수 있습니다.
```

**13) 80번 포트를 점유하고 있는 프로세스의 pid를 변수에 저장합니다.**
```bash
pid=$(sudo netstat -tulpn | grep ':80' | awk '{print $7}' | cut -d'/' -f1)
```
```desc
#### 🆔 포트 점유 프로세스 PID 추출하기
`netstat` 결과에서 `awk`와 `cut`을 이용해 80번 포트를 사용하는 프로세스의 PID만 정확히 추출하여 변수에 저장합니다.

- **`awk '{print $7}'`**: 7번째 필드(PID/프로그램이름)를 출력
- **`cut -d'/' -f1`**: '/'를 기준으로 잘라 첫 번째 부분(PID)만 가져옴

> 💡 텍스트 처리 도구를 조합하여 원하는 정보만 뽑아내는 것은 셸 스크립팅의 핵심 기술입니다.
```

**14) pid를 통해 프로세스를 확인합니다.**
```bash
ps -ef | grep "$pid"
```
```desc
#### 📛 PID로 프로세스 이름 확인하기
추출한 PID를 이용해 `ps` 명령어로 해당 프로세스의 상세 정보를 확인합니다.

- **`ps -ef`**: 시스템의 모든 프로세스를 상세하게 표시
- **`| grep "$pid"`**: PID 변수에 해당하는 프로세스 정보를 필터링

> 💡 이를 통해 PID가 실제로 `nginx` 프로세스임을 다시 한번 확인할 수 있습니다.
```

**15) nginx 웹서버를 중지합니다.**
```bash
sudo systemctl stop nginx
```
```desc
#### ⏹️ Nginx 서비스 중지하기
포트 충돌을 해결하기 위해 80번 포트를 점유하고 있는 Nginx 서비스를 중지합니다.

- **`sudo systemctl stop nginx`**: `nginx` 서비스를 중지합니다.

> 💡 이제 80번 포트는 다른 프로세스가 사용할 수 있는 상태가 됩니다.
```

**16) 80번 포트를 다시 확인합니다**
```bash
sudo netstat -tulpn | grep ':80'
```
```desc
#### ✅ 80번 포트 비어있는지 확인
`netstat`으로 80번 포트가 더 이상 사용되지 않는지 확인합니다.

- **`sudo netstat -tulpn | grep ':80'`**: 80번 포트를 사용하는 프로세스를 검색
- 아무런 결과도 출력되지 않아야 정상입니다.

> 💡 포트가 비었음을 확인하고 다음 단계를 진행하는 것이 중요합니다.
```

**17) httpd 웹서버를 다시 시작합니다.**
```bash
sudo systemctl start httpd
```
```desc
#### ▶️ httpd 서비스 다시 시작하기
이제 80번 포트가 비었으므로 `httpd` 서비스를 다시 시작합니다.

- **`sudo systemctl start httpd`**: `httpd` 서비스 시작

> 💡 이번에는 포트 충돌이 없으므로 정상적으로 시작되어야 합니다.
```

**18) httpd 웹서버 작동 상태를 확인합니다**
```bash
sudo systemctl status httpd
```
```desc
#### 📊 httpd 상태 확인하기
`httpd` 서비스가 정상적으로 실행되었는지 확인합니다.

- **`sudo systemctl status httpd`**: `httpd` 서비스의 상태를 보여줍니다.
- `Active: active (running)` 메시지가 보이면 성공입니다.

> 💡 포트 충돌 문제가 해결되었음을 의미합니다.
```

**19) httpd 웹서버가 정상적으로 응답하는지 확인합니다.**
```bash
curl http://localhost/index.php
```
```desc
#### ✅ httpd 응답 확인하기
`curl`을 이용해 `httpd` 서버가 정상적으로 응답하는지 확인합니다.

- **`curl http://localhost/index.php`**: 로컬호스트의 `httpd` 서버에 `index.php`를 요청합니다.

> 💡 "Hello from httpd (PHP)!" 메시지가 출력되면 포트 충돌 문제를 완전히 해결한 것입니다.
```
