##### 실행 중인 프로세스 메모리 사용량 어떻게 조회하나요?#####

**1) 1000초 동안 잠자는 `sleep` 프로세스를 백그라운드에서 실행합니다.**
```bash
sleep 1000 &
```
```tech
sleep
```
```desc
#### ⏳ 백그라운드에서 프로세스 실행하기
`sleep` 명령어를 사용하여 지정된 시간 동안 대기하는 프로세스를 만들고, `&`를 붙여 백그라운드에서 실행합니다.

- **`sleep 1000`**: 1000초 동안 아무 작업도 하지 않고 대기
- **`&`**: 명령어를 백그라운드에서 실행시켜, 바로 다음 명령어를 입력할 수 있게 함

> 💡 테스트용 프로세스를 만들어 메모리 사용량을 측정하기 위한 준비 단계입니다.
```

**2) `pgrep`을 사용해 PID를 확인합니다.**
```bash
pgrep sleep
```
```tech
pgrep
```
```desc
#### 🆔 이름으로 프로세스 ID(PID) 찾기
`pgrep`은 특정 이름을 가진 프로세스의 ID(PID)를 찾아주는 명령어입니다.

- **`pgrep sleep`**: 이름이 `sleep`인 모든 프로세스의 PID를 출력

> 💡 `ps aux | grep sleep` 보다 훨씬 간결하게 PID만 얻을 수 있어 스크립트에서 활용하기 좋습니다.
```

**3) `ps` 명령어를 사용하여 메모리 사용량을 확인합니다.**
```bash
ps -o pid,user,%mem,rss,vsz -p $(pgrep sleep)
```
```tech
ps,pgrep
```
```desc
#### 📊 `ps`로 메모리 사용량 확인하기
`ps` 명령어와 `-o` 옵션을 사용하여 원하는 형식으로 프로세스 정보를 출력합니다.

- **`-o`**: 출력 형식 지정 (pid, user, %mem, rss, vsz)
- **`%mem`**: 실제 메모리 사용 비율
- **`rss`**: 실제 사용 중인 물리 메모리 크기 (Resident Set Size)
- **`vsz`**: 사용 중인 가상 메모리 전체 크기 (Virtual Memory Size)
- **`-p`**: 특정 PID를 지정

> 💡 `rss`가 실제 메모리 점유율을 파악하는 데 더 중요한 지표입니다.
```

**4) `top` 명령어를 사용하여 메모리 사용량을 확인합니다.(q로 종료)**
```bash
top -p $(pgrep sleep)
```
```tech
top,pgrep
```
```desc
#### 实时 `top`으로 메모리 사용량 확인하기
`top` 명령어는 실시간으로 시스템 상태와 프로세스 정보를 보여주는 도구입니다.

- **`-p`**: 특정 PID의 프로세스만 관찰
- **`q`**: `top` 명령어 종료

> 💡 `top`은 계속해서 정보가 갱신되므로, 특정 프로세스의 상태 변화를 실시간으로 모니터링할 때 매우 유용합니다.
```

**5) `/proc` 파일 시스템을 사용하여 메모리 사용량을 확인합니다.**
```bash
grep VmRSS /proc/$(pgrep sleep)/status
```
```tech
grep,pgrep
```
```desc
#### 💾 `/proc`에서 메모리 사용량 확인하기
`/proc` 파일 시스템의 `status` 파일을 통해 프로세스의 상세한 상태 정보를 직접 확인할 수 있습니다.

- **`/proc/[PID]/status`**: 프로세스의 상태 정보 파일
- **`grep VmRSS`**: `status` 파일 내용 중 `VmRSS` (실제 물리 메모리 사용량) 라인만 필터링

> 💡 `ps`의 `rss` 값과 동일하며, 시스템의 가장 기본적인 정보를 직접 조회하는 방법입니다.
```

**6) 실습이 끝난 후 `sleep` 프로세스를 종료합니다.**
```bash
kill $(pgrep sleep)
```
```tech
kill,pgrep
```
```desc
#### ⏹️ 프로세스 종료하기
`kill` 명령어를 사용하여 특정 PID를 가진 프로세스를 종료합니다.

- **`kill [PID]`**: 해당 PID의 프로세스에 종료 신호(기본값: SIGTERM)를 보냄

> 💡 `$(pgrep sleep)`을 통해 얻은 PID를 바로 `kill` 명령어에 전달하여 `sleep` 프로세스를 깔끔하게 종료할 수 있습니다.
```