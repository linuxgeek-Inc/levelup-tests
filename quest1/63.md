##### 실행 중인 프로세스 heap, stack 주소 범위 확인하려면?#####

**1) 1000초 동안 잠자는 `sleep` 프로세스를 백그라운드에서 실행합니다.**
```bash
sleep 1000 &
```
```tech
sleep
```
```desc
#### ⏳ 백그라운드에서 프로세스 실행하기
`sleep` 명령어를 사용하여 지정된 시간 동안 대기하는 프로세스를 만들고, `&`를 붙여 백그라운드에서 실행합니다.

- **`sleep 1000`**: 1000초 동안 아무 작업도 하지 않고 대기
- **`&`**: 명령어를 백그라운드에서 실행시켜, 바로 다음 명령어를 입력할 수 있게 함

> 💡 백그라운드 프로세스는 터미널을 계속 사용할 수 있게 해주므로 시간이 오래 걸리는 작업을 할 때 유용합니다.
```

**2) `pgrep`을 사용해 PID를 확인합니다.**
```bash
pgrep sleep
```
```tech
pgrep
```
```desc
#### 🆔 이름으로 프로세스 ID(PID) 찾기
`pgrep`은 특정 이름을 가진 프로세스의 ID(PID)를 찾아주는 명령어입니다.

- **`pgrep sleep`**: 이름이 `sleep`인 모든 프로세스의 PID를 출력

> 💡 `ps aux | grep sleep` 보다 훨씬 간결하게 PID만 얻을 수 있어 스크립트에서 활용하기 좋습니다.
```

**3) 프로세스의 메모리 맵 정보를 확인합니다.**
```bash
cat /proc/$(pgrep sleep)/maps
```
```tech
cat,pgrep
```
```desc
#### 🗺️ 프로세스 메모리 맵 확인하기
`/proc` 파일 시스템을 통해 실행 중인 프로세스의 상세한 메모리 할당 정보를 확인합니다.

- **`/proc/[PID]/maps`**: 특정 PID를 가진 프로세스의 메모리 영역(코드, 데이터, 스택, 힙 등)과 주소 범위를 보여주는 파일
- **`$(pgrep sleep)`**: 명령어의 실행 결과를 이 위치에 삽입 (PID로 치환됨)

> 💡 이 파일은 커널이 제공하는 가상 파일로, 프로세스의 메모리 구조를 분석할 때 매우 유용합니다.
```

**4) `grep`을 사용하여 힙과 스택 정보만 필터링합니다.**
```bash
grep -e 'heap' -e 'stack' /proc/$(pgrep sleep)/maps
```
```tech
grep,pgrep
```
```desc
#### 🔍 힙(heap)과 스택(stack) 정보 필터링
`grep`을 사용하여 `maps` 파일의 내용 중 'heap' 또는 'stack'이라는 단어가 포함된 줄만 골라냅니다.

- **`grep -e '패턴1' -e '패턴2'`**: 여러 개의 패턴을 동시에 찾을 때 사용

> 💡 `[heap]`은 동적으로 할당되는 메모리 영역, `[stack]`은 함수 호출과 지역 변수가 저장되는 메모리 영역을 의미합니다.
```

**5) 실습이 끝난 후 `sleep` 프로세스를 종료합니다.**
```bash
kill $(pgrep sleep)
```
```tech
kill,pgrep
```
```desc
#### ⏹️ 프로세스 종료하기
`kill` 명령어를 사용하여 특정 PID를 가진 프로세스를 종료합니다.

- **`kill [PID]`**: 해당 PID의 프로세스에 종료 신호(기본값: SIGTERM)를 보냄

> 💡 `$(pgrep sleep)`을 통해 얻은 PID를 바로 `kill` 명령어에 전달하여 `sleep` 프로세스를 깔끔하게 종료할 수 있습니다.
```