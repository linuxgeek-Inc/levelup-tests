##### 프로세스 정상종료(SIGTERM) 어떻게 해야하나요?#####

**1) 1000초 동안 대기하는 `sleep` 프로세스를 실행합니다.**
```bash
sleep 1000 &
```
```tech
sleep
```
```desc
#### ⏳ 테스트용 프로세스 실행하기
`sleep` 명령어를 백그라운드에서 실행하여 종료 시그널을 테스트할 대상 프로세스를 만듭니다.

- **`sleep 1000`**: 1000초 동안 아무 작업도 하지 않고 대기
- **`&`**: 백그라운드에서 실행

> 💡 `sleep`은 특정 시간 동안 대기하는 간단한 명령어라서 프로세스 제어 실습에 자주 사용됩니다.
```

**2) `pgrep`으로 PID를 확인합니다.**
```bash
pgrep sleep
```
```tech
pgrep
```
```desc
#### 🆔 이름으로 프로세스 ID(PID) 찾기
`pgrep`을 사용하여 'sleep'이라는 이름을 가진 프로세스의 PID를 찾습니다.

- **`pgrep`**: 프로세스 이름이나 특정 조건으로 PID를 검색하는 명령어
- **`sleep`**: 찾고자 하는 프로세스의 이름

> 💡 `ps` 명령어와 `grep`을 조합하는 것보다 훨씬 간편하게 PID를 찾을 수 있습니다.
```

**3) `kill` 명령어를 사용하여 `SIGTERM` 시그널을 보냅니다.**
```bash
kill $(pgrep sleep)
```
```tech
kill,pgrep
```
```desc
#### gentle 젠틀하게 프로세스 종료하기 (SIGTERM)
`kill` 명령어로 `sleep` 프로세스에 `SIGTERM` 시그널을 보내 정상적으로 종료하도록 요청합니다.

- **`kill`**: 시그널을 보내는 명령어. 시그널을 명시하지 않으면 기본적으로 `SIGTERM`을 보냅니다.
- **`$(pgrep sleep)`**: 명령어 치환. `pgrep sleep`의 실행 결과(PID)가 이 자리에 들어갑니다.

> 💡 `SIGTERM`은 "이제 종료해주세요"라고 정중하게 요청하는 것과 같습니다. 프로세스는 이 시그널을 받고 안전하게 종료 준비를 할 수 있습니다.
```

**4) 프로세스가 종료되었는지 확인합니다.**
```bash
pgrep sleep
```
```tech
pgrep
```
```desc
#### ✅ 프로세스 종료 확인하기
`pgrep`을 다시 실행하여 `sleep` 프로세스가 완전히 종료되었는지 확인합니다.

- **`pgrep sleep`**: `sleep` 프로세스를 검색

> 💡 아무런 PID도 출력되지 않으면 프로세스가 성공적으로 종료된 것입니다.
```

**5) `SIGTERM`을 무시하는 셸 스크립트를 실행합니다.**
```bash
bash -c 'trap "" SIGTERM; echo "PID is $$"; while true; do sleep 1; done' &
```
```tech
bash,trap,echo,while,sleep
```
```desc
#### 🛡️ 종료 신호 무시하는 프로세스 만들기
`trap` 명령어를 사용하여 `SIGTERM` 시그널을 받았을 때 아무 작업도 하지 않도록 설정된 특별한 프로세스를 실행합니다.

- **`bash -c '...'`**: 따옴표 안의 스크립트를 새로운 bash 셸에서 실행
- **`trap "" SIGTERM`**: `SIGTERM` 시그널을 무시하도록 설정 (트랩)
- **`$`**: 현재 셸의 PID를 나타내는 특수 변수

> 💡 이 프로세스는 `SIGTERM` 시그널을 받아도 종료되지 않으므로, 강제 종료(`SIGKILL`)를 테스트하기 좋습니다.
```

**6) 스크립트의 PID를 변수에 저장합니다.**
```bash
TRAP_PID=$!
```
```tech
bash
```
```desc
#### 🆔 종료되지 않는 프로세스 PID 저장하기
방금 실행한 `SIGTERM` 무시 스크립트의 PID를 `TRAP_PID` 변수에 저장합니다.

- **`TRAP_PID=$!`**: 가장 최근에 백그라운드로 실행된 프로세스의 PID(`$!`)를 변수에 할당

> 💡 변수를 사용하면 복잡한 PID를 계속 입력할 필요 없이 편리하게 관리할 수 있습니다.
```

**7) `SIGTERM`을 보내도 종료되지 않는 것을 확인합니다.**
```bash
kill ${TRAP_PID}
```
```tech
kill
```
```desc
#### 🚫 종료 요청이 무시되는지 확인하기
`kill` 명령어로 `SIGTERM`을 보내 `trap`으로 설정된 프로세스가 정말로 종료되지 않는지 확인합니다.

- **`kill ${TRAP_PID}`**: `TRAP_PID`에 저장된 프로세스에 `SIGTERM` 전송

> 💡 `trap` 설정 때문에 이 명령어는 아무런 효과가 없을 것입니다.
```

**8) 프로세스가 여전히 살아있는지 확인합니다.**
```bash
sleep 2 && ps -p ${TRAP_PID}
```
```tech
sleep,ps
```
```desc
####  살아있는지 확인하기
`ps` 명령어로 `SIGTERM`을 보낸 후에도 프로세스가 여전히 실행 중인지 확인합니다.

- **`sleep 2`**: 시그널 처리 시간을 감안하여 2초 대기
- **`&&`**: 앞 명령이 성공하면 뒤 명령 실행
- **`ps -p ${TRAP_PID}`**: 해당 PID의 프로세스 정보 출력

> 💡 프로세스 정보가 출력된다면, `SIGTERM`이 성공적으로 무시되었음을 의미합니다.
```

**9) `SIGKILL`을 사용하여 프로세스를 강제 종료합니다.**
```bash
kill -9 ${TRAP_PID}
```
```tech
kill
```
```desc
#### 💥 프로세스 강제 종료하기 (SIGKILL)
`SIGTERM`을 무시하는 프로세스를 `SIGKILL`(-9) 시그널로 강제 종료합니다.

- **`kill -9`**: `SIGKILL` 시그널을 보냄. 프로세스가 무시할 수 없는 가장 강력한 종료 신호입니다.
- **`${TRAP_PID}`**: 강제 종료할 프로세스의 PID

> ⚠️ `SIGKILL`은 프로세스에게 정리할 시간을 주지 않고 즉시 종료시키므로, 데이터 유실 등의 위험이 있어 최후의 수단으로 사용해야 합니다.
```
