##### CPU 100% 프로세스 어떻게 찾고 종료하죠?#####

**1) 테스트용 CPU 100% 프로세스 생성 (yes)**

```bash
yes > /dev/null &
```

```tech
yes,bash,rocky
```

```desc
#### ⚡️ CPU 부하를 유발하는 테스트 프로세스 생성
`yes` 명령어를 백그라운드에서 실행하여 의도적으로 CPU 사용량을 높입니다.

- **`yes`**: 'y' 문자열을 무한히 출력하는 명령어
- **`> /dev/null`**: 출력되는 모든 내용을 버려서 화면이 어지러워지는 것을 방지
- **`&`**: 프로세스를 백그라운드에서 실행

> 💡 이 명령은 CPU 성능 테스트나 부하 상황을 시뮬레이션할 때 유용합니다.
```

**2) 프로세스가 정상 실행 중인지 pid 확인**

```bash
pgrep yes
```

```tech
pgrep,bash,rocky
```

```desc
#### 🆔 프로세스 ID(PID) 찾기
`pgrep`을 사용해 'yes'라는 이름의 프로세스 ID(PID)를 찾습니다.

- **`pgrep`**: 이름이나 다른 속성을 이용해 프로세스 ID를 찾는 명령어
- **`yes`**: 찾고 싶은 프로세스의 이름

> 💡 `kill` 같은 다른 명령어와 조합하여 특정 프로세스를 제어할 때 매우 유용합니다.
```

**3) 현재 CPU 사용량 상위 프로세스 확인 (top) (실행 후 q로 종료)**

```bash
top -o %CPU
```

```tech
top,bash,rocky
```

```desc
#### 📊 CPU 사용량 높은 순으로 프로세스 확인 (실시간)
`top` 명령어로 시스템 상태를 실시간으로 보면서 CPU 사용량(`%CPU`)이 높은 순으로 정렬합니다.

- **`top`**: 시스템의 프로세스, CPU, 메모리 사용 현황을 실시간으로 보여줌
- **`-o %CPU`**: CPU 사용량을 기준으로 정렬하여 표시 (`o`는 Override-Sort-Field)

> 💡 시스템이 느려졌을 때 어떤 프로세스가 문제인지 찾기 위해 가장 먼저 사용하는 명령어 중 하나입니다. `q`를 눌러 종료합니다.
```

**4) 현재 CPU 사용량 상위 프로세스 확인 (ps)**

```bash
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head
```

```tech
ps,bash,rocky
```

```desc
#### 📋 CPU 사용량 높은 순으로 프로세스 목록 확인 (순간)
`ps` 명령어로 현재 시점의 프로세스 정보를 CPU 사용량 순으로 정렬하여 상위 몇 개만 봅니다.

- **`ps -eo ...`**: 사용자가 지정한 형식(`-o`)으로 모든 프로세스(`-e`) 정보를 출력
- **`pid,cmd,%cpu`**: 프로세스 ID, 명령어, CPU 사용률 등 보고 싶은 정보
- **`--sort=-%cpu`**: CPU 사용량을 기준으로 내림차순 정렬 (`-`가 내림차순)
- **`| head`**: 결과를 상위 10개 라인만 보여줌

> 💡 `top`과 달리 특정 순간의 스냅샷을 보거나, 스크립트에서 활용하기 좋습니다.
```

**5) 프로세스 이름(yes)로 PID 찾아 안전 종료 (pidof + kill)**

```bash
sudo kill $(pidof yes)
```

```tech
pidof,kill,bash,rocky
```

```desc
#### 🛑 프로세스 안전하게 종료하기
`pidof`로 'yes' 프로세스의 PID를 찾아 `kill` 명령어로 종료 신호(기본값: SIGTERM)를 보냅니다.

- **`sudo`**: `kill` 명령을 관리자 권한으로 실행
- **`kill`**: 프로세스에 특정 신호를 보내 제어하는 명령어
- **`$(pidof yes)`**: `pidof yes` 명령어의 실행 결과를 이 위치에 삽입 (PID)

> 💡 `kill`은 프로세스가 하던 일을 정리하고 종료할 시간을 주는 '안전한' 종료 방식입니다.
```

**6) 프로세스 다시 생성 (yes)**

```bash
yes > /dev/null &
```

```tech
yes,bash,rocky
```

```desc
#### 🔄 테스트 프로세스 재생성
종료 테스트를 위해 CPU 부하를 유발하는 `yes` 프로세스를 다시 실행합니다.

- **`yes > /dev/null &`**: 'y'를 무한 출력하는 프로세스를 백그라운드에서 실행

> 💡 다른 종료 방식을 테스트하기 위해 동일한 조건의 프로세스를 준비하는 과정입니다.
```

**7) 프로세스 이름(yes)로 PID 찾아 강제 종료 (pgrep + kill -9)**

```bash
sudo kill -9 $(pgrep yes)
```

```tech
pgrep,kill,bash,rocky
```

```desc
#### 💥 프로세스 강제로 종료하기
`pgrep`으로 'yes' 프로세스의 PID를 찾아 `kill -9` (SIGKILL) 신호로 즉시 강제 종료합니다.

- **`kill -9`**: 프로세스의 상태와 관계없이 즉시 종료시키는 가장 강력한 신호
- **`$(pgrep yes)`**: `pgrep`으로 찾은 'yes' 프로세스의 PID

> ⚠️ 강제 종료는 데이터 유실이나 파일 손상을 일으킬 수 있으므로, 일반적인 방법으로 종료되지 않을 때만 최후의 수단으로 사용해야 합니다.
```

**8) 실습 종료**

```bash
: quit
```

```tech
bash,rocky
```

```desc
#### 👋 실습 종료
실습을 종료를 의미하는 `quit` 명령어를 실행합니다.
현재 터미널 세션을 종료합니다.

> 💡 모든 실습을 마친 후 사용합니다.
```
